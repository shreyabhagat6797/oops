'''
•	A class is a user-defined blueprint or prototype from which objects are created.
•	Class Definition Syntax:

class ClassName:
# Statement-1
.
.
# Statement-N

•	An Object is an instance of a Class. 
•	self
Class methods must have an extra first parameter in the method definition. 


'''

#creating class & declaring of objects 
class Engineer:
    attr1="IT"         #attributes
    attr2="Non-it"

    def func(self):            #method
        print("he is from ",self.attr1)
        print("she is from ",self.attr2)

Engg=Engineer()   #object instantiation

print(Engg.attr1)    #accessing class attributes & methods using objects
Engg.func()

'''
•	__init__ method is used to initializing the object’s state.

•	Constructors are used to initializing the object’s state.
•	Types of constructors :
1.	default constructor 
2.	parameterized constructor 

'''

class Person:
    def __init__(self,name): #constructor
        self.name=name

    def func(self):   #sample method
        print("hello,my name is",self.name)

p=Person("steve")
p.func()

'''
•	Destructors are called when an object gets destroyed. 
'''

class Employee:
    def __init__(self):
        print("employee created")

    def func(self):   #sample method
        print("hello,my name is")

    def __del__(self):
        print("destructor called , employee deleted")

object=Employee()
del object  


####
class Dog:
    animal="dog" #class variables

    def __init__(self,breed,color):
        self.breed=breed   #instance variables
        self.color=color

    def set_age(self,age): #set values
        self.age=age

    def get_age(self):   #view values
        return self.age

Rodger=Dog("Pug","white")
Buzo=Dog("Bulldog","black")

Rodger.set_age("4")
print(Rodger.get_age())

print("Rodger is ",Rodger.animal)
print("breed is ",Rodger.breed)
print("color is ",Rodger.color)

print("buzo is ",Buzo.animal)
print("breed is ",Buzo.breed)
print("color is ",Buzo.color)

#example
class Addition:
    first=0
    second=0
    answer=0

    def __init__(self,f,s):
        self.first=f
        self.second=s

    def calculate(self):
        self.answer=self.first+self.second

    def display(self):
        print("first number= ",(self.first))
        print("second number= ",(self.second))
        print("answer is ",(self.answer))

object=Addition(4,5)
object.calculate()
object.display()


'''
Create a class with a couple of functions like these examples.
•	magic.replace("string", 'char', char') is a function that replaces all of the specified characters with another characters.
•	magic.str_length("string") is a function that returns the length of the string.
•	magic.trim(" string ") is a function that returns a string that truncates spaces at both the beginning and end.
•	magic.list_slice(list, tuple) is a function that returns the items in the list that are among the specified indexes. 
If the length of the new list is 0, return -1.

Examples
magic.replace("AzErty-QwErty", "E", "e") ➞ "Azerty-Qwerty"

magic.str_length("hello world") ➞ 11

magic.trim("      python is awesome      ") ➞ "python is awesome"

magic.list_slice([1, 2, 3, 4, 5], (2, 4)) ➞ [ 2, 3, 4 ]

'''


class Magic:
    def replace(self,string,char1,char2):
        return string.replace(char1,char2)

    def str_length(self,string):
        return len(string)

    def trim(self,string):
        return string.strip()

    def list_slice(self,list,tuple):
        return list[slice(tuple[0]-1,tuple[1])]

magic=Magic()
print(magic.replace("AzErty-QwErty", "E", "e"))
print(magic.str_length("hello world"))
print(magic.trim("      python is awesome      "))
print(magic.list_slice([1, 2, 3,7,8,9, 4, 5], (2, 5)))


#polymorphism
'''same function but used in deifferent types'''

print(len("python"))
print(len(["python","java","c"]))
print(len({"name":"python","language":"moderate"}))


num1=4
num2=5
print(num1+num2)

str1="python"
str2="language"
print(str1+" "+str2)


class Cat:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def info(self):
        print(f"I am cat.My name is {self.name}.I am {self.age} years old")

class Dog:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def info(self):
        print(f"I am dog.My name is {self.name}.I am {self.age} years old")

c=Cat("kitty",2)
d=Dog("brucy",4)

for animal in (c,d):
    animal.info()
    

#encapsulation

class Computer:
    def __init__(self):
        self.__maxprice=400

    def sell(self):
        print("selling price is {}".format(self.__maxprice))

    def set_maxprice(self,price):
        self.__maxprice=price

c=Computer()
c.sell()

c.__maxprice=500
c.sell()

c.set_maxprice(500)
c.sell()

#abstraction

#from abc import abstractmethod



from abc import ABC, abstractmethod   
class Car(ABC):   
    def mileage(self):   
        pass  
  
class Tesla(Car):   
    def mileage(self):   
        print("The mileage is 30kmph")   
class Suzuki(Car):   
    def mileage(self):   
        print("The mileage is 25kmph ")   
class Duster(Car):   
     def mileage(self):   
          print("The mileage is 24kmph ")   
  
class Renault(Car):   
    def mileage(self):   
            print("The mileage is 27kmph ")   
          
# Driver code   
t= Tesla ()   
t.mileage()   
  
r = Renault()   
r.mileage()   
  
s = Suzuki()   
s.mileage()   
d = Duster()   
d.mileage() 



Inheritance in python
•	Inheritance is, a class that inherits all the methods and properties from another class.



•	Properties:
1.	It represents real-world relationships well. 
2.	It provides reusability of code.
3.	It is transitive in nature.
                


•	Types of Inheritance:
1.	Single Inheritance
2.	Multiple Inheritance
3.	Multilevel Inheritance
4.	Hierarchical Inheritance
5.	 Hybrid Inheritance

•	Single Inheritance:
When a child class inherits from only one parent class, it is called single inheritance.
    

•	Multiple Inheritance:
When a child class inherits from multiple parent classes, it is called multiple inheritance. 


•	Multilevel Inheritance:
When we have a child and grandchild relationship.


•	Hierarchical Inheritance:
More than one derived classes are created from a single base.


•	Hybrid Inheritance:
This form combines more than one form of inheritance.


 Super() Function:
Super function allows us to call a method from the parent class.
Example-
Let’s take an example of animals. Dogs, cats and cows are part of animals. They also share common characteristics like –  
•	They are mammals.
•	They have a tail and four legs.
•	They are domestic animals.

Method Overriding
You can override a method in python
The functionality of the parent class method is changes by overriding the same method in the child class.



#single inhertance
class Parent:
    def func1(self):
        print("this is in parent class")

class Child(Parent):
    def func2(self):
        print("this is in child class")

c=Child()
c.func1()
c.func2()

#mutiple inhertance

class Mother:
    mothername=" "
    def mother(self):
        print(self.mothername)

class Father:
    fathername=" "
    def father(self):
        print(self.fathername)

class Son(Mother,Father):
    def parent(self):
        print("Father: ",self.fathername)
        print("Mother: ",self.mothername)

s=Son()
s.fathername="Ram"
s.mothername="sita"
s.parent()

#multilevel inheritance

class Grandfather:
    def __init__(self,grandfathername):
        self.grandfathername=grandfathername

class Father(Grandfather):
    def __init__(self,fathername,grandfathername):
        self.fathername=fathername

        Grandfather.__init__(self,grandfathername) #invoking constructor

class Son(Father):
    def __init__(self,sonname,fathername,grandfathername):
        self.sonname=sonname

        Father.__init__(self,fathername,grandfathername)   #invoking constructor

    def print(self):
        print("Grandfather: ",self.grandfathername)
        print("Father: ",self.fathername)
        print("Son: ",self.sonname)

s=Son("Prince","Ram","Mani")
s.print()

#hierarchical inheritance

class Parent:
    def func1(self):
        print("this is in parent class")

class Child1(Parent):
    def func2(self):
        print("this is in child1")

class Child2(Parent):
    def func3(self):
        print("this is in child2")

c1=Child1()
c2=Child2()

c1.func1()
c1.func2()

c2.func1()
c2.func3()

#hybrid inheritance

class School:
    def func1(self):
        print("this is in school")

class Student1(School):
    def func2(self):
        print("this is in student1")

class Student2(School):
    def func3(self):
        print("this is in student2")

class Student3(Student1,School):
    def func4(self):
        print("this is in student3")

s=Student3()
s.func1()
s.func4()
s.func2()

s1=Student2()
s1.func3()


#super function
class Animals:
    def __init__(self):
        self.legs=4
        self.domestic=True
        self.tail=True
        self.mammals=True

    def is_mammal(self):
        if self.mammals:
            print("it is mammal")

    def is_domestic(self):
        if self.domestic:
            print("it is domestic animal")

class Dog(Animals):
    def __init__(self):
        super().__init__()

    def is_mammal(self):
        super().is_mammal()

class Cow(Animals):
    def __init__(self):
        super().__init__()

    def hasTailandLegs(self):
        if self.tail and self.legs==4:
            print("has tail and legs")

d=Dog()
d.is_mammal()
c=Cow()
c.hasTailandLegs()
 

#method overriding

class Parent:
    def func1(self):
        print("this is in parent class")

class Child(Parent):
    def func1(self):
        print("this is in child class")

c=Child()
c.func1()


Assignment 1
WeCare insurance company wants to calculate premium of vehicles.
Vehicles are of two types – "Two Wheeler" and "Four Wheeler". Each vehicle is identified by vehicle id, type, cost and premium amount.
Premium amount is 2% of the vehicle cost for two wheelers and 6% of the vehicle cost for four wheelers. Calculate the premium amount and display the vehicle details.
Identify the class name and attributes to represent vehicles. 
•	calculate_premium()
•	vehicle_cost
•	TwoWheeler
•	vehicle_type
•	vehicle_id
•	Vehicle
•	premium_amount
•	FourWheeler
•	premium_percentage
•	calculate_vehicle_cost()
•	__init__()
•	display_vehicle_details()
Write a Python program to implement the class chosen with its attributes and methods.
Note:
1.	Consider all instance variables to be private and methods to be public
2.	Include getter and setter methods for all instance variables
3.	Display appropriate error message, if the vehicle type is invalid
4.	Perform case sensitive string comparison
Represent few objects of the class, initialize instance variables using setter methods, invoke appropriate methods and test your program.

class Vehicle:
    def __init__(self):
        self.__vehicle_cost=None
        self.__vehicle_id=None
        self.__vehicle_type=None
        self.__premium_amount=None
        
    def set_vehicle_id(self,vehicle_id):
        self.__vehicle_id=vehicle_id
    def set_vehicle_type(self,vehicle_type):
        if check_type(vehicle_type):
            self.__vehicle_type=vehicle_type
        else:
            return "invalid Vehicle DETAILS"
    def set_vehicle_cost(self,vehicle_cost):
        self.__vehicle_cost=vehicle_cost
    def get_vehicle_id(self):
        return self.__vehicle_id
    def get_vehicle_type(self):
        return self.__vehicle_type
    def get_vehicle_cost(self):
        return self.__vehicle_cost
    def set_premium_amount(self,premium_amount):
        self.__premium_amount=premium_amount
    def get_premium_amount(self):
        return self.__premium_amount
        
    def calculate_premium(self):
        if self.__vehicle_type=="Two Wheeler":
            self.__premium_amount=self.__vehicle_cost*2/100
        elif self.__vehicle_type=="Four Wheeler":
            self.__premium_amount=self.__vehicle_cost*6/100
        else:
            print("Invalid Vehicle Type")
            
    def display_vehicle_details(self):
        print(self.__premium_amount)

def check_type(type):
    vehicle_type=['Two Wheeler', 'Four Wheeler']
    if type not in vehicle_type:
            return 0
    return 1

v1 = Vehicle()
#v1.set_vehicle_id=10
v1.set_vehicle_type("Two Wheeler")
v1.set_vehicle_cost(105000)
v1.calculate_premium()
v1.display_vehicle_details()


TechWorld, a technology training center, wants to allocate courses for instructors.
An instructor is identified by name, technology skills, experience and average feedback.
An instructor is allocated a course, if he/she satisfies the below two conditions:
•	eligibility criteria:
•	if experience is more than 3 years, average feedback should be 4.5 or more
•	if experience is 3 years or less, average feedback should be 4 or more
•	he/she should posses the technology skill for the course
Identify the class name and attributes from the list of options below to represent instructors.
•	check_eligibility()
•	avg_feedback
•	experience
•	instructor_name
•	allocate_course()
•	allocate_course(technolody)
•	__init__()
•	Instructor
•	calculate_avg_feedback()
•	technology_skill
Write a Python program to implement the class chosen with its attributes and methods.
Note:
1.	Consider all instance variables to be private and methods to be public
2.	An instructor may have multiple technology skills, so consider instance variable, technology_skill to be a list
3.	check_eligibility(): Return true if eligibility criteria is satisfied by the instructor. Else, return false
4.	allocate_course(technology): Return true if the course which requires the given technology can be allocated to the instructor. Else, return false
5.	Perform case sensitive string comparison
Represent few objects of the class, initialize instance variables using setter methods, invoke appropriate methods and test your program.

class Instructor:
    def __init__(self):
        self.__instructor_name=None
        self.__experience=None
        self.__avg_feedback=None
        self.__technology_skill=None
        
    def set_instructor_name(self,instructor_name):
        self.__instructor_name=instructor_name
        
    def set_experience(self,experience):
        self.__experience=experience
        
    def set_avg_feedback(self,avg_feedback):
        self.__avg_feedback=avg_feedback
        
    def set_technology_skill(self,technology_skill):
        self.__technology_skill=technology_skill
        
    def get_instructor_name(self):
        return self.__instructor_name
    
    def get_experience(self):
        return self.__experience
        
    def get_avg_feedback(self):
        return self.__avg_feedback
        
    def get_technology_skill(self):
        return self.__technology_skill
        
    def check_eligibility(self):
        if self.__experience>3 and self.__avg_feedback>=4.5:
            return True
        elif self.__experience<=3 and self.__avg_feedback>=4:
            return True
        else:
            return False
            
    def allocate_course(self,technology):
        if((technology==self.__technology_skill) or (technology=="C++")):
            return True
        else:
            return False

i=Instructor()
i.set_avg_feedback(5)
i.set_experience(4)
print(i.check_eligibility())

A university wants to automate their admission process. Students are admitted based on marks scored in a qualifying exam.
A student is identified by student id, age and marks in qualifying exam. Data are valid, if:
•	Age is greater than 20
•	Marks is between 0 and 100 (both inclusive)
A student qualifies for admission, if
•	Age and marks are valid and
•	Marks is 65 or more
Write a python program to represent the students seeking admission in the university.
The details of student class are given below.
Class name: Student
Attributes
(private)	student_id
marks
age	 
Methods
(public)	__init__()	Create and initialize all instance variables to None
 	validate_marks()	 
If data is valid, return true. Else, return false
 	validate_age()	
 	check_qualification()	Validate marks and age.
•	If valid, check if marks is 65 or more.
o	If so return true
o	Else return false
•	Else return false
 	setter methods	Include setter methods for all instance variables to set its values
 	getter methods	Include getter methods for all instance variables to get its values

student_id_counter=1
class Student:
   
    def __init__(self):
        self.__student_id=None
        self.__marks=None
        self.__age=None
    def validate_marks(self):
        if self.__marks>=0 and self.__marks<=100:
            return True
        else:
            return False
    def validate_age(self):
        if self.__age>20:
            return True
        else:
            return False
    def check_qualification(self):
        if self.validate_age() and self.validate_marks():
            if self.__marks>=65:
                return True
        return False
    def set_student_id(self):
        global student_id_counter
        self.__student_id=student_id_counter
        student_id_counter=student_id_counter+1
    def get_student_id(self):
        return self.__student_id
    def set_marks(self, marks):
        self.__marks=marks
    def get_marks(self):
        return self.__marks
    def set_age(self, age):
        self.__age=age
    def get_age(self):
        return self.__age
        
    #id = property(set_student_id, get_student_id)
    #marks = property(set_marks, get_marks)
    #age = property(set_age, get_age)
s1=Student()
s1.set_student_id()
print(s1.get_student_id())
s1.set_age(21)
print(s1.get_age())
s1.set_marks(66)
print(s1.get_marks())
print(s1.check_qualification())

Continuing with the previous scenario, a student eligible for admission has to choose a course and pay the fees for it. If they have scored more than 85 marks in qualifying exam, they get 25% discount on fees.
Valid course ids and fees are given below:
course id	fees
1001	25575.0
1002	15500.0
Extend the program written in the previous assignment to include the above requirement.
Instance variables and methods to be included in Student class are given below.
Class name: Student
Attributes
(private)	course_id
fees	 
Methods
(public)	__init__()	Create and initialize newly created instance variables also to None
 	choose_course(course_id)	Accept the course_id chosen by the student.
•	If course_id is valid,
o	set attributes course_id and fees
o	if marks is more than 85, apply 25% discount on fees
o	return true
•	Else, return false
 	getter methods	Include getter methods for newly added instance variables
 
courses={1001:25575,1002:15500}

class Student:
    def __init__(self):
        self.__student_id=None
        self.__marks=None
        self.__age=None
        self.__course_id=None
        self.__fees=None

    def validate_marks(self):
        if self.__marks>=0 and self.__marks<=100:
            return True 
        else:
            return False

    def validate_age(self):
        if self.__age>20:
            return True
        else:
            return False

    def check_qualification(self):
        if self.validate_marks() and self.validate_age():
            if self.__marks>=65:
                return True
        return False

    def choose_course(self,course_id):
        if course_id in courses.keys():
            self.__course_id=course_id
            if self.__marks>=85:
                self.__fees=courses[course_id]*0.75
                print("Fees : ",self.__fees)
                return True
            else:
                return False
        else:
            return False
            
    def set_marks(self,marks):
        self.__marks=marks

    def get_marks(self):
        return self.__marks

    def set_age(self,age):
        self.__age=age

    def get_age(self):
        return self.__age

    def set_student_id(self,student_id):
        self.__student_id=student_id

    def get_student_id(self):
        return self.__student_id

    def get_course_id(self):
        return self.__course_id
    
    def get_fees(self):
        return self.__fees

s=Student()
s.set_student_id(10)
s.set_marks(87)
s.set_age(25)
if(s.check_qualification()):
    print("student is qualified")
    if (s.choose_course(1002)):
        print("course is alloted")
    else:
        print("invalid course")
else:
    print("student not qualified")
Assignment 2

Royal Orchid is a florist. They want to be alerted when stock of a flower goes below a particular level. 
The flowers are identified using name, price per kg and stock available (in kgs).
Write a Python program to implement the above requirement.
Details of Flower class are given below:
Class name: Flower
Attributes
(private)	flower_name
price_per_kg
stock_available	 
Methods
(public)	__init__()	Create and initialize all instance variables to None
	validate_flower()	Return true, if flower name is valid. Else, return false
(Refer table for valid flower names)
	validate_stock(required_quantity)	Accept the quantity required. Return true, if stock is available.
Else return false.
	sell_flower(required_quantity)	Accept the quantity required.
Validate flower name and stock.
If both are valid, update stock available based on the quantity required
	check_level()	Check if available stock is below the order level
If so, return true. Else, return false
(Refer table for order level of each flower)
	setter methods	Include setter methods for all instance variables to set its values
	getter methods	Include getter methods for all instance variables to get its values
 
 
Flower Name	Level(in Kgs)
Orchid	15
Rose	25
Jasmine	40
Note: Perform case insensitive string comparison
Represent few flowers, initialize instance variables using setter methods, invoke appropriate methods and test your program.
flowers=['Orchid','Rose','Jasmine']
levels=[15,25,40]
class Flower:
    def __init__(self):
        self.__flower_name=None
        self.__price_per_kg=None
        self.__stock_available=None
    def validate_flower(self):
        if self.__flower_name in flowers:
            return True
        else:
            return False
    def validate_stock(self, required_quantity):
        if self.__stock_available>=required_quantity:
            return True
        else:
            return False
    def sell_flower(self,required_quantity):
        if self.validate_flower() and self.validate_stock(required_quantity):
            self.__stock_available -= required_quantity
    def check_level(self):
        if self.validate_flower():
            flower_level=levels[flowers.index(self.__flower_name)]
            if self.__stock_available<flower_level:
                return True
        return False
    def get_flower_name(self):
        return self.__flower_name
    def get_price_per_kg(self):
        return self.__price_per_kg
    def get_stock_available(self):
        return self.__stock_available
    
    def set_flower_name(self, flower_name):
        self.__flower_name=flower_name.title()
    def set_price_per_kg(self,price_per_kg):
        self.__price_per_kg=price_per_kg
    def set_stock_available(self, stock_available):
        self.__stock_available=stock_available
a=Flower()
a.set_flower_name('Rose')
a.set_price_per_kg(200)
a.set_stock_available(25)
print(a.get_flower_name())
print(a.get_price_per_kg())
print(a.get_stock_available())
print(a.check_level())

#flower_name-Roseprice_per_kg-200stock_available-25

Care hospital wants to calculate the bill amount to be paid by patients visiting the hospital. Bill amount includes consultation fees and price of medicines purchased from their pharmacy.
Write a Python program to implement the class diagram given below.
                                                                                 
Method description:
calculate_bill_amount(consultation_fees, quantity_list, price_list): Accept consultation_fees, quantity_list (quantities of medicines purchased) and price_list (price per quantity of medicines purchased)
a.	Calculate total bill amount to be paid by the patient. Bill amount includes consultation fees and price of medicines
b.	Initialize attribute, bill_amount with the total bill amount
Note: quantity_list and price_list have one-to-one correspondence. Quantity and price per quantity of 1st medicine purchased by the patient is present at 0th index of both lists, 2nd medicine is present at 1st index and so on.

For testing:
•	Create objects of Bill class
•	Invoke calculate_bill_amount(consultation_fees, quantity_list, price_list) method on Bill object by passing consultation fees, quantity list and price list
•	Display bill id, patient name and bill amount

class Bill:
    def __init__(self,bill_id,patient_name):
        self.__bill_id=bill_id
        self.__patient_name=patient_name
        self.__bill_amount=0

    def get_bill_id(self):
        return self.__bill_id

    def get_patient_name(self):
        return self.__patient_name

    def get_bill_amount(self):
        return self.__bill_amount

    def calculate_bill(self,consultation_fees, quantity_list, price_list):
        for i in range(len(quantity_list)):
            self.__bill_amount+=(quantity_list[i]*price_list[i])
        self.__bill_amount+=consultation_fees

b=Bill(100,"ABC")
print(b.get_patient_name())
print(b.get_bill_id()) 
b.calculate_bill(500,[1,2],[20,30])
print(b.get_bill_amount())


Assignment 3
Freight Pvt. Ltd, a cargo company, forwards cargos/freights between its customers.
Freight charges are applied based on weight and distance of the shipment.
Write a python program to implement the class diagram given below.
  

Method description:
1.	Initialize counter variable to 198 in Freight class
2.	All validate methods should return true, if validation succeeds. Else it should return false
3.	validate_customer_id(): Customer id should be 6 digits and should begin with digit 1
4.	validate_weight(): Weight should be a multiple of 5
5.	validate_distance(): Distance should be between 500kms and 5000kms (both inclusive)
6.	forward_cargo():
•	Validate from_customer.customer_id, recipient_customer.customer_id, distance and weight of the freight
•	If valid,
•	auto-generate freight_id starting from 200 and initialize it. freight_id should be even
•	calculate freight_charge based on weight (Rs.150/kg) and distance (Rs.60/km)
•	Else, set freight_charge to 0

For testing:
•	Create objects of Customer and Freight class
•	Invoke forward_cargo() method on Freight object
•	Display freight id and freight charge
•	In case of error/invalid data, display appropriate error message

class Freight:
    counter=198
    def __init__(self, recipient_customer, from_customer, weight, distance):
        self.__recipient_customer=recipient_customer
        self.__from_customer=from_customer
        self.__weight=weight
        self.__distance=distance
        self.__freight_id=0
        self.__freight_charge=0
    def validate_weight(self):
        if self.__weight%5==0:
            return True
        else:
            return False
    def validate_distance(self):
        if self.__distance>=500 and self.__distance<=5000:
            return True
        else:
            return False
    def forward_cargo(self):
        if Customer.validate_customer_id(self.__from_customer) and Customer.validate_customer_id(self.__recipient_customer) and  self.validate_distance() and self.validate_weight():
            self.__freight_id = Freight.counter+2            
            Freight.counter += 2
            self.__freight_charge=(self.__weight*150)+(self.__distance*60)
            return self.__freight_id and self.__freight_charge            
        else:
            self.__freight_charge=0
            
    def get_freight_charge(self):
        return self.__freight_charge
    def get_freight_id(self):
        return self.__freight_id
    def get_recipient_customer(self):
        self.__recipient_customer
    def get_from_customer(self):
        self.__from_customer
    def get_weight(self):
        self.__weight
    def get_distance(self):
        self.__distance
    
class Customer:
    def __init__(self, customer_id, customer_name, address):
        self.__customer_id = customer_id
        self.__customer_name = customer_name
        self.__address = address
        
    def validate_customer_id(self):
        id=str(self.__customer_id)
        if(id[0]=='1' or len(id)==6):
            return True
        else:
            return False
    def get_customer_id(self):
        return self.__customer_id
    def get_customer_name(self):
        return self.__customer_name
    def get_address(self):
        return self.__address
        
c1=Customer(112345,"jill","chennai")
c2=Customer(1,"Omkar123","hedvgsdv")
f1=Freight(c1,c2,15,505)
print(f1.validate_distance())
print(f1.forward_cargo())
print(f1.get_freight_id())

In the retail store scenario, let's look at the portion of customer purchasing items from the retail store.

Class Description: 
Bill class:
1.	Initialize static variable counter to 1000
2.	generate_bill_amount(item_quantity,items): Calculate bill amount based on the items purchased by the customer
a.	Accept a dictionary, item_quantity which contains the item id (key) of the items purchased along with the quantity (value)
b.	Accept a list, items which contains the list of Item objects available in the store
c.	Generate bill id starting from 1001 prefixed by "B" and initialize attribute, bill_id. Ex. "B1001", "B1002" etc.
d.	Calculate bill amount based on the quantity and price of the items purchased by the customer
e.	Set attribute, bill_amount with the calculated bill amount
Assume that values in item_quantity and items are always valid. 
Customer class:
pays_bill(bill): Pay bill based on the bill amount
a.	Accept Bill object which contains the details of the bill to be paid by the customer
b.	Update attribute, payment_status to "Paid"
c.	Display customer name, bill id and bill amount
Note: Perform case insensitive string comparison

For testing:
•	Create objects of Customer class, Item class and Bill class
•	Invoke generate_bill_amount(item_quantity,items) on Bill object by passing the dictionary containing item_id and quantity of items purchased by the Customer and list of Item objects
•	Invoke pays_bill() on Customer object by passing the Bill object


items=[]
class Item:
    def __init__(self,item_id,description,price_per_quantity):
        self.__item_id=item_id.upper()
        self.__description=description.upper()
        self.__price_per_quantity=price_per_quantity
        items.append(self)
    def get_item_id(self):
        return self.__item_id
    def get_description(self):
        return self.__description
    def get_price_per_quantity(self):
        return self.__price_per_quantity
        
class Bill:
    counter=1000
    def __init__(self):
        self.__bill_id=1000
        self.__bill_amount=0
    def generate_bill_amount(self,item_quantity, items):
        if not self.__bill_amount:
            for key,value in item_quantity.items():
                for item in items:
                    if item.get_item_id()==key.upper():
                        self.__bill_amount += value*item.get_price_per_quantity()
                        continue
            if self.__bill_amount>0:
                self.__bill_id="B"+str(Bill.counter+1)
                Bill.counter += 1
            
    def get_bill_id(self):
        return self.__bill_id
    def get_bill_amount(self):
        return self.__bill_amount
        
class Customer:
    def __init__(self, customer_name):
        self.__customer_name=customer_name
        self.__payment_status=None
    def pays_bill(self,bill):
        self.__payment_status="Paid"
        print(self.get_customer_name())
        print(bill.get_bill_id())
        print(bill.get_bill_amount())
    def get_customer_name(self):
        return self.__customer_name
    def get_payment_status(self):
        return self.__payment_status
item_quantity = {'Ir987':3, 'IR346':2, 'IR658':4, 'IR123':2}
c=Customer("Omkar")
i1=Item("IR987","Sunfeast Marie",100.0)
i2=Item("ir658","Kellogs Oats",151.0)
i3=Item("Ir346","Maggie Noodles",35.75)
i4=Item("iR234","Kissan Jam",100.0)
i5=Item("IR123","Nescafe",55.5)
i6=Item("IR111","Milk",100.0)

b=Bill()
b.generate_bill_amount(item_quantity,items)
b.generate_bill_amount(item_quantity,items)
b.generate_bill_amount(item_quantity,items)
b.generate_bill_amount(item_quantity,items)
b.generate_bill_amount(item_quantity,items)

c.pays_bill(b)
#print(b.get_bill_id())
#print(b.get_bill_amount())

# c.pays_bill(b)








Assignment 4

An apparel shop wants to manage the items which it sells. 
Write a python program to implement the class diagram given below.
  
Class Description:
Apparel class:
1.	Initialize static variable counter to 100
2.	In the constructor, auto-generate item_id starting from 101 prefixed by "C" for cotton apparels and "S" for silk apparels. Example – C101, S102, S103, C104 etc.
3.	calculate_price(): Add 5% service tax on the price of the apparel and update attribute, price with the new value
Cotton class:
1.	While invoking parent constructor from child constructor, pass "Cotton" as item_type
2.	calculate_price(): Update attribute, price of Apparel class based on rules given below
a.	Add service tax on price by invoking appropriate method of Apparel class
b.	Apply discount on price
c.	Add 5% VAT on final price
Silk class:
1.	While invoking parent constructor from child constructor, pass "Silk" as item_type
2.	calculate_price(): Update attribute, price of Apparel class based on rules given below
a.	Add service tax on price by invoking appropriate method of Apparel class
b.	Identify points earned based on rules given below:
•	Silk apparels with price more than Rs. 10000, earn 10 points and anything less than or equal to that earn 3 points
c.	Initialize attribute, points with the identified points
d.	Add 10% VAT on price
Note: Perform case sensitive string comparison  

For testing:
•	Create objects of Cotton class and Silk class
•	Invoke calculate_price() on Cotton objects and Silk objects
•	Display their details

class Apparel:
    counter=100
    def __init__(self, price, item_type):
        self.__item_id=item_type[0].upper()+str(Apparel.counter+1)
        self.__price=price
        self.__item_type=item_type.title()
        Apparel.counter+=1
    def get_item_id(self):
        return self.__item_id
    def get_item_type(self):
        return self.__item_type
    def get_price(self):
        return self.__price
    def calculate_price(self):
        self.__price *=  1.05
    def set_price(self, price):
        self.__price=price
class Cotton(Apparel):
    def __init__(self, price,discount):
        Apparel.__init__(self, price, "Cotton")
        self.__discount = discount
    def calculate_price(self):
        Apparel.calculate_price(self)
        price = Apparel.get_price(self)
        price *= (1-((self.__discount)/100))
        price *= (1.05)
        Apparel.set_price(self, price)
        
    def get_discount(self):
        return self.__discount
class Silk(Apparel):
    def __init__(self, price):
        Apparel.__init__(self, price, "Silk")
        self.__points=0
    def calculate_price(self):
        Apparel.calculate_price(self)
        price = self.get_price()
        if price >10000:
            self.__points +=10
        else:
            self.__points += 3
        price = price * 1.10
        Apparel.set_price(self, price)
        return price
        
    def get_points(self):
        return self.__points
        
a = Silk(1320)

print(a.calculate_price())

Coorg Fruit Farm is a retail chain which sells fruits grown in their orchards in Coorg, India.
They want to keep track of customers who buy fruits from them and also the billing process. Write a python program to implement the class diagram given below.
 
Class Description:
Fruit Info class:
1.	fruit_name_list: Static list which contains the list of fruits available
2.	fruit_price_list: Static list which contains the price/kg of fruits
3.	The above two lists have one-to-one correspondence, initialize it with the data given in the table
4.	get_fruit_price(fruit_name): Accept a fruit name and return its price/kg. If fruit is not available, return -1
Fruit Name	Apple	Guava	Orange	Grape	Sweet Lime
Price per Kg	200	80	70	110	60
Purchase class:
1.	Initialize static variable counter to 101
2.	calculate_price(): Calculate and return total fruit price based on rules given below
a.	For valid fruit name (hint: invoke get_fruit_price(fruit_name)),
•	Calculate price based on price/kg and quantity of the fruit purchased by the customer
•	If price/kg of the fruit is maximum among the fruits in fruit lists and quantity purchased is more than 1kg, apply 2% discount on calculated price
•	If price/kg of the fruit is minimum among the fruits in fruit lists and quantity purchased is 5kg or more, apply 5% discount on calculated price
•	If the customer is a "wholesale" customer, provide an additional 10% discount. Apply this discount on already discounted price, if any one of the above two points are applicable. Else apply it on calculated price
•	Auto-generate purchase id starting from 101 prefixed by “P”. Example – P101,P102 P103 etc.
•	Return final fruit price
b.	Else, return -1.
Note:
•	Perform case sensitive string comparison 
•	There will be only one fruit with maximum price and one with minimum price

For testing:
•	Create objects of Customer and Purchase class
•	Invoke calculate_price() on Purchase object
•	Display the details

class FruitInfo:
    __fruit_name_list=['Apple', 'Guava', 'Orange', 'Grape', 'Sweet Lime']
    __fruit_price_list=[100, 800, 70, 110, 600]
    @staticmethod
    def get_fruit_price(fruit_name):
        if fruit_name.title() in FruitInfo.__fruit_name_list:
            return FruitInfo.__fruit_price_list[FruitInfo.__fruit_name_list.index(fruit_name.title())]
        else:
            return -1
    @staticmethod
    def get_fruit_name_list():
        return FruitInfo.__fruit_name_list
    @staticmethod
    def get_fruit_price_list():
        return FruitInfo.__fruit_price_list
class Purchase:
    __counter=101
    def __init__(self, customer,fruit_name, quantity):
        self.__purchase_id=None
        self.__customer=customer
        self.__fruit_name=fruit_name.title()
        self.__quantity=quantity
    def get_purchase_id(self):
        return self.__purchase_id
    def get_customer(self):
        return self.__customer
    def get_quantity(self):
        return self.__quantity
    def calculate_price(self):
        each_fruit_price=FruitInfo.get_fruit_price(self.__fruit_name)
        if each_fruit_price>0:
            self.__purchase_id = 'P' + str(Purchase.__counter)
            Purchase.__counter += 1
            price=each_fruit_price*self.__quantity
            if each_fruit_price==max(FruitInfo.get_fruit_price_list()) and self.__quantity>1:
                price*=0.98
            if each_fruit_price==min(FruitInfo.get_fruit_price_list()) and self.__quantity>=5:
                price*=0.95
            #even if you insert 'Wholesale' in customer type, and check here for 'Wholesale'(i.e if Customer.get_cust_type(self.__customer) is 'Wholesale' and you are checking against 'Wholesale'), still the program will not pass all the test cases. It has to be 'wholesale' and not 'Wholesale'. So it is very very important to read the question carefully and only mention those words/letters as instructed in the questoion.
            if Customer.get_cust_type(self.__customer)=='wholesale':
                price*=0.90
            return (price)
        else:
            return -1
                
            
class Customer():
    def __init__(self, customer_name, cust_type):
        self.__customer_name=customer_name.title()
        #self.__cust_type=cust_type.title() will give wrong answer because in the question it is clearly mentioned that if the customer_type is 'wholesale' not 'Wholesale'. Also check at Line 40 
        self.__cust_type=cust_type.lower()
    def get_customer_name(self):
        return self.__customer_name
    def get_cust_type(self):
        return self.__cust_type
        
c=Customer("Tom", "wholesale")
p=Purchase(c,"Orange", 5)
print(p.calculate_price())

"WonderLand" water theme park wants to generate tickets for its customers.
Complete the implementation of the requirement based on the given class diagram and code.
                         
Class Description:
Theme Park class: Complete the class based on comments given in starter code
Ticket class: Complete the class based on comments given in starter code
Customer class:
1.	Initialize points_earned, food_coupon and ticket to 0, "No" and a Ticket object respectively in the constructor
2.	play_game():
a.	Calculate total points based on the list of games played by the customer
b.	Update attribute, points_earned with the calculated value
c.	ThemePark allows a free ride on Game 2 if the customer has opted for Game 3. If this is satisfied, add "Game2" to list_of_games and include its points to total points
3.	update_food_coupon(): They provide food coupon to a customer who has opted Game 4 and has earned more than 15 points.
a.	Update attribute, food_coupon status to "Yes" if the above rule is satisfied
4.	book_ticket():
a.	Calculate ticket amount
b.	If amount can be calculated, generate ticket id, play game, update food coupon and return true
c.	Else, return false
Note: Perform case sensitive string comparison
class ThemePark:
    #dict_of_games contains the game name as key, price/ride and points that can be earned by customer in a list as value
    dict_of_games={"Game1":[35.5,5], "Game2":[40.0,6],"Game3":[120.0,10], "Game4":[60.0,7],"Game5":[25.0,4]}
    @staticmethod
    def validate_game(game_input):
        pass
        #Remove pass and write the logic here
        #If game_input is present in ThemePark, return true. Else, return false.
    @staticmethod
    def get_points(game_input):
        pass
        #Remove pass and write the logic here
        #Return the points that can be earned for the given game_input.
    @staticmethod
    def get_amount(game_input):
        pass
        #Remove pass and write the logic here
        #Return the price/ride for the given game_input

#This class represents ticket
class Ticket:
    __ticket_count=200
    def __init__(self):
        self.__ticket_id=None
        self.__ticket_amount=0
    def generate_ticket_id(self):
        pass
        #Remove pass and write the logic here
        #Auto-generate ticket_id starting from 201
    def calculate_amount(self, list_of_games):
        pass
        #Remove pass and write the logic here
        '''Validate the games in the list_of_games.
        If all games are valid, calculate total ticket amount and assign it to attribute, ticket_amount and return true. Else, return false'''
    def get_ticket_id(self):
        return self.__ticket_id
    def get_ticket_amount(self):
        return self.__ticket_amount

class Customer:
    pass
    #Remove pass and implement class Customer here

'''Represent customers and display all details of the customer, if he is able to book the ticket and play the game. Else, display appropriate error message '''

class ThemePark:
    #dict_of_games contains the game name as key, price/ride and points that can be earned by customer in a list as value
    dict_of_games={"Game1":[35.5,5], "Game2":[40.0,6],"Game3":[120.0,10], "Game4":[60.0,7],"Game5":[25.0,4]}
    @staticmethod
    def validate_game(game_input):
        if game_input.title() in ThemePark.dict_of_games.keys():
            return True
        else:
            return False
        #If game_input is present in ThemePark, return true. Else, return false.
    @staticmethod
    def get_points(game_input):
        for game,point in ThemePark.dict_of_games.items():
            if game_input.title()==game:
                return point[1]
        #Return the points that can be earned for the given game_input.
    @staticmethod
    def get_amount(game_input):
        for game,point in ThemePark.dict_of_games.items():
            if game_input.title()==game:
                return point[0]
        #Return the price/ride for the given game_input
#This class represents ticket
class Ticket:
    __ticket_count=200
    def __init__(self):
        self.__ticket_id=None
        self.__ticket_amount=0
    def generate_ticket_id(self):
        self.__ticket_id=Ticket.__ticket_count+1
        Ticket.__ticket_count+=1
        #Auto-generate ticket_id starting from 201
    def calculate_amount(self, list_of_games):
        for game in list_of_games:
            if ThemePark.validate_game(game):
                self.__ticket_amount+=ThemePark.get_amount(game)
            else:
                self.__ticket_amount=0
                return False
        return True
        '''Validate the games in the list_of_games.
        If all games are valid, calculate total ticket amount and assign it to attribute, ticket_amount and return true. Else, return false'''
    def get_ticket_id(self):
        return self.__ticket_id
    def get_ticket_amount(self):
        return self.__ticket_amount

class Customer:
    def __init__(self, name, list_of_games):
        self.__name=name
        self.__list_of_games=list_of_games
        self.__ticket=Ticket()
        self.__points_earned=0
        self.__food_coupon="No"
    def play_game(self):
        for game in self.__list_of_games:
            self.__points_earned+=ThemePark.get_points(game)
            if game=="Game3":
                self.__list_of_games.append("Game2")
    def update_food_coupon(self):
        if "Game4" in self.__list_of_games and self.__points_earned>15:
            self.__food_coupon="Yes"
    def book_ticket(self):
        if Ticket.calculate_amount(self.__ticket, self.__list_of_games):
            Ticket.generate_ticket_id(self.__ticket)
            self.play_game()
            self.update_food_coupon()
            return True
        else:
            return False
    def get_name(self):
        return self.__name
    def get_list_of_games(self):
        return self.__list_of_games
    def get_ticket(self):
        return self.__ticket
    def get_points_earned(self):
        return self.__points_earned
    def get_food_coupon(self):
        return self.__food_coupon

t=Ticket()

c=Customer("fhfj",["Game4","Game3","Game2"])
t=Ticket()
print(t.calculate_amount(["Game4","Game3","Game2"]))
print(t.get_ticket_amount())

t.generate_ticket_id()

print(t.get_ticket_id())

c.play_game()
c.update_food_coupon()
print(c.get_points_earned())
print(c.get_food_coupon())
print(c.book_ticket())



Assignment 5

PizzaForYou is a pizza store which sells different kinds of pizzas based on customer's order.
Customer can either collect the order in person or opt for a door delivery.
Customer class:
1.	validate_quantity(): A customer can order 1 to 5 pizzas
a.	If quantity is valid, return true. Else return false
Pizzaservice class:
1.	Initialize static variable counter to 100
2.	Attribute, additional_topping is a boolean value which indicates whether additional topping is required or not.True – additional topping is required, False – additional topping is not required
3.	validate_pizza_type(): Customers can order "small" or "medium" type pizzas
a.	If pizza type is valid, return true. Else return false
4.	calculate_pizza_cost(): Calculate pizza cost
a.	Validate pizza type and quantity
b.	If valid,
•	Identify pizza cost based on details mentioned in the table
•	Set attribute, pizza_cost with the calculated pizza cost
•	Auto-generate service_id starting from 101 prefixed by first letter of pizza type. Example – S101, s102, m103, S104, M105 etc
c.	If invalid, set pizza_cost to -1
PizzaType	Cost/Pizza(in Rs)	Additional topping cost/Pizza (in Rs), if applicable
Small	150	35
Medium	200	50
 
Doordelivery class:
1.	validate_distance_in_kms(): Minimum distance for door delivery is 1km and maximum is 10kms
a.	Validate distance_in_kms
b.	If valid, return true. Else, return false
2.	calculate_pizza_cost: Calculate pizza cost
a.	Validate distance in kms
b.	If valid,
•	Calculate pizza cost (Hint: Invoke overridden method in parent class)
•	If pizza_cost is not -1, identify delivery charge based on details mentioned below and add it to attribute, pizza_cost
	
Distance in kms	Delivery Charge in km(in Rs)
For first 5 kms	5
For remaining 5 kms	7
c.	Else, set pizza_cost to -1
Note: Perform case insensitive string comparison  
For testing :
•	Create objects of Pizzaservice and Doordelivery classes
•	Invoke calculate_pizza_cost() on Pizzaservice and Doordelivery objects
•	Display the details

types=['small', 'medium', 'Small', 'Medium']
class Customer:
    def __init__(self, customer_name, quantity):
        self.__customer_name=customer_name.title()
        self.__quantity=quantity
    def validate_quantity(self):
        if self.__quantity in range(1,6):
            return True
        else: 
            return False
    def get_customer_name(self):
        return self.__customer_name
    def get_quantity(self):
        return self.__quantity
    
class Pizzaservice:
    counter=100
    def __init__(self, customer, pizza_type, additional_topping):
        self.__customer = customer
        self.__pizza_type = pizza_type
        self.__additional_topping = additional_topping
        self.pizza_cost = 0
        self.__service_id=None
    def validate_pizza_type(self):
        if self.__pizza_type.lower() in types:
            return True
        else:
            return False
    def calculate_pizza_cost(self):
        if self.validate_pizza_type() and Customer.validate_quantity(self.__customer):
            if self.__pizza_type.title() == "Small" :
                self.pizza_cost=150 * Customer.get_quantity(self.__customer)
                if self.__additional_topping:
                    self.pizza_cost+=35 * Customer.get_quantity(self.__customer)
            if self.__pizza_type.title()=="Medium":
                self.pizza_cost=200 * Customer.get_quantity(self.__customer)
                if self.__additional_topping:
                    self.pizza_cost+=50 *  Customer.get_quantity(self.__customer)
            if not self.__service_id:
                self.__service_id = self.__pizza_type[0] + str(Pizzaservice.counter+1)
                Pizzaservice.counter+=1
        else:
            self.pizza_cost=-1
    def get_service_id(self):
        return self.__service_id
    def get_pizza_type(self):
        return self.__pizza_type
    def get_customer(self):
        return self.__customer
    def get_additional_topping(self):
        return self.__additional_topping
class Doordelivery(Pizzaservice):
    def __init__(self, customer, pizza_type, additional_topping, distance_in_kms):
        self.__delivery_charge=0
        self.__distance_in_kms = distance_in_kms
        Pizzaservice.__init__(self, customer, pizza_type, additional_topping)
    def validate_distance_in_kms(self):
        if self.__distance_in_kms in range(1,11):
            return True
        else:
            return False
    def calculate_pizza_cost(self):
        if self.validate_distance_in_kms():
            Pizzaservice.calculate_pizza_cost(self)
            if self.pizza_cost!= -1:
                distance=1
                while(distance<=self.__distance_in_kms):
                    if distance in range(1,6):
                        self.pizza_cost += 5
                    if distance in range(6,11):
                        self.pizza_cost += 7
                    distance += 1
        else:
            self.pizza_cost = -1
    def get_delivery_charge(self):
        return self.__delivery_charge
    def get_distance_in_kms(self):
        return self.__distance_in_kms
c = Customer("Asha", 5)
d = Pizzaservice(c, "MEDIUM", True)
d.calculate_pizza_cost()
d.calculate_pizza_cost()
d.calculate_pizza_cost()
d.calculate_pizza_cost()
d.calculate_pizza_cost()

print(d.pizza_cost)
print(d.get_service_id())





sss
import math
from abc import ABCMeta, abstractmethod
# metaclass=ABCMeta):
class Logistics(metaclass=ABCMeta):
    __counter=None
    def __init__(self,start_reading,end_reading):
        self.__consumer_id=None
        self.__start_reading=start_reading
        self.__end_reading=end_reading
    def get_consumer_id(self):
        return self.__consumer_id
    def get_start_reading(self):
        return self.__start_reading
    def get_end_reading(self):
        return self.__end_reading
    def validate_meter_reading(self):
        if(self.__start_reading >= self.__end_reading):
            return False
        else:
            return True
    def generate_consumer_id(self):
        if not Logistics.__counter:
            Logistics.__counter=7000
        if not self.__consumer_id:
            self.__consumer_id = Logistics.__counter + 1
            Logistics.__counter += 1
    @abstractmethod
    def calculate_bill_amount(self):
        pass
class PassengerLogistics(Logistics):
    __list_vehicle=["BMW","TOYOTA","FORD"]
    __list_minimum_charge=[3000,1500,1000]
    __list_charge_for_hundred=[30,15,10]
    __list_charge_after_hundred=[25,12,7]
    def __init__(self,vehicle_type,start_reading,end_reading):
        super().__init__(start_reading,end_reading)
        self.__vehicle_type=vehicle_type
    def get_vehicle_type(self):
        return self.__vehicle_type
    def validate_vehicle_type(self):
        for index in range(0,len(PassengerLogistics.__list_vehicle)):
            if(PassengerLogistics.__list_vehicle[index]==self.__vehicle_type):
                return index
        return -1
    def calculate_bill_amount(self):
        if self.validate_vehicle_type()>=0 and self.validate_meter_reading():
            self.generate_consumer_id()
            distance_travelled = self.get_end_reading() - self.get_start_reading()
            distance = 1
            bill_amount=0
            index = PassengerLogistics.__list_vehicle.index(self.get_vehicle_type())
            while(distance<=distance_travelled):
                if distance<=100:
                    bill_amount+=PassengerLogistics.__list_charge_for_hundred[index]
                if distance>100:
                    bill_amount+=PassengerLogistics.__list_charge_after_hundred[index]
                distance += 1
            if PassengerLogistics.__list_minimum_charge[index]>bill_amount:
                bill_amount=PassengerLogistics.__list_minimum_charge[index]
            bill_amount*=1.05
            return bill_amount
        else:
            bill_amount=-1
            return bill_amount
            
class GoodsLogistics(Logistics):
    __carrier_dict={"EICHER": 38, "FORCE": 42, "TATA": 25} # stores the carrier type and rate per kilometer for 1000kg
    def __init__(self,carrier_type,goods_weight,start_reading,end_reading):
        super().__init__(start_reading,end_reading)
        self.__carrier_type=carrier_type
        self.__goods_weight=goods_weight
    def get_carrier_type(self):
        return self.__carrier_type
    def get_goods_weight(self):
        return self.__goods_weight
    def validate_carrier_type(self):
        for carrier in GoodsLogistics.__carrier_dict:
            if(carrier==self.__carrier_type):
                return True
        return False
    def calculate_bill_amount(self):
        if(self.validate_carrier_type()):
            if(self.validate_meter_reading()):
                self.generate_consumer_id()
                total_distance=self.get_end_reading()-self.get_start_reading()
                multiplier = math.ceil(self.__goods_weight/1000)-1
                charge_per_kilometer=0
                bill_amount=0
                if(self.__goods_weight<=1000):
                    charge_per_kilometer=GoodsLogistics.__carrier_dict[self.__carrier_type]
                elif(self.__goods_weight >1000 and self.__goods_weight<=3000):
                    charge_per_kilometer=self.__carrier_dict[self.__carrier_type]*2**multiplier
                else:
                    charge_per_kilometer=200
                bill_amount+=total_distance*charge_per_kilometer
                bill_amount*=1.10
                bill_amount+=2000
                return bill_amount
            else:
                return -1
        else:
            return -1
# # _Logistics__counter-None(Method invoked 5 times)
# passenger_logistic=PassengerLogistics("TOYOTA",300,400)
# bill_amount=passenger_logistic.calculate_bill_amount()

# # bill_amount=passenger_logistic.calculate_bill_amount()
# if(bill_amount==-1):
#     print("Invalid vehicle type or meter reading ")
# else:
#     print("Consumer id    :",passenger_logistic.get_consumer_id())
#     print("Start reading  :",passenger_logistic.get_start_reading())
#     print("End reading    :",passenger_logistic.get_end_reading())
#     print("Total Amount   :",bill_amount)
# print("------------------------------------------------------------")
goods_logistic=GoodsLogistics("TATA",2000,300,400)
bill_amount=goods_logistic.calculate_bill_amount()
if(bill_amount==-1):
    print("Invalid career type or meter reading ")
else:
    print("Consumer id    :",goods_logistic.get_consumer_id())
    print("Goods weight   :",goods_logistic.get_goods_weight())
    print("Start reading  :",goods_logistic.get_start_reading())
    print("End reading    :",goods_logistic.get_end_reading())
    print("Total Amount   :",bill_amount)


